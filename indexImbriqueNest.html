<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cercles imbriqués selon les attributs</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>
h2 {
    font-size: 12px;
    margin: 0;
    padding:0;
    text-align: center;
}
.node {
  cursor: pointer;
  stroke: #f0f0f0;
  stroke-width:1px;
}

.node--leaf {
  fill: white;
}

.label {
  font: 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
  text-anchor: middle;
  text-shadow: 0 2px 0 #fff, 2px 0 0 #fff, -2px 0 0 #fff, 0 -2px 0 #fff;
}

.label,
.node--root,
.node--leaf {
  pointer-events: none;
}

circle.hovered{
    
  stroke: black;
  stroke-width: 1.5px;
    }

.ghost {
    opacity: 0.01;
}

.hidden-labels {
    display: none !important;
}

/*.node[class*="top"] {
     stroke: orangered; 
}

.node[class*="med"] {
      stroke: yellow;
}
.node[class*="topmed"] {
      stroke: orange;
}
.node[class*="low"] {
      stroke: cornflowerblue;
}
.node[class*="lowmed"] {
   stroke: lightblue;
   
}*/

nav ul {
    list-style: none;
    padding:0;
    display: flex;
    flex-wrap: wrap;
}

nav ul li {
    background: #ddd;
    padding:3px 6px;
    margin: 0 5px;
    border-radius: 10px;
}

nav ul li a {
    text-decoration: none;
    cursor: pointer;
}
</style>
</head>

<body>
    <nav>
        <ul>
            <li><a href="indexImbrique.html">Cercles imbriqués</a></li>
            <li><a href="indexImbriqueNest.html">Cercles imbriqués selon les attributs</a></li>
            <li><a href="IndexIcicle.html">Glaçons</a></li>
            <li><a href="IndexRadial.html">Noeuds-liens radial</a></li>
            <li><a href="indexRadialNest.html">Noeuds-liens radial selon la médiane des attributs</a></li>
            <li><a href="indexExo2.html">Coordonnées parallèles</a></li>
        </ul>
    </nav>
    <header><h1>TP - Bryan Colle et Ali Daoudi</h1>
        <div class="scale">
            <svg id="scale-svg"></svg>
            <p>La couleur et le rayon des cercles varie selon l'attribut sélectionné. Les couleurs dépendent du quantile.</p>
            <button onclick="ghostLow('points', 1892)">Mettre en évidence les 10 meilleurs</button>
            <button onclick="unghostAll()">Réinitialiser</button>
            <button onclick="toggleLabels()">Toggle labels</button>
        </div>
    </header>

    <script src="makeScale.js"></script>


<script>
    /* Global data for the svgs */
    const diameter = 800;
    const margin = 4;
    var svgData = {};
    var view;
    var currentlyHovered;
    var showLabel = true;

    var div = d3.select("body").append("div").attr("style", "display:inline-block;min-height: " + diameter + ", min-width:" + diameter);
    div.append("h2").text("Points");
    var svg = div.append("svg").attr("width", diameter).attr("height", diameter).attr("class", "viz"),
        g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

    var pack = d3.pack()
        .size([diameter - margin, diameter - margin])
        .padding(2);
  d3.tsv("nba-no-hierarchy-original.txt", function (error, data) {
        if (error) throw error;

        data = makeNest(data, [
            {
                attribute: "Minutes/Game",
                classes: ["top", "topmed", "lowmed", "low"]
            },
            {
                attribute: "Turnovers/Game",
                classes: ["top", "topmed", "lowmed", "low"]
            },
            {
                attribute: "Total Rebounds/Game",
                classes: ["top", "topmed", "lowmed", "low"]
            },
            {
                attribute: "Games Played",
                classes: ["top", "topmed", "lowmed", "low"]
            }
        ]);
        
        data = { key: "nba", values: data };

        pointsValues = [];
        var root = d3.hierarchy(data, function (d) {
            return d.values;
        })
            .sum(function (d) { if (d.Points) pointsValues.push(parseInt(d.Points)); return d.Points; })
            .sort(function (a, b) { return b.value - a.value; });

        svgData = { focus: root, nodes: pack(root).descendants(), values: pointsValues };
        var color = makeQuantileScale(svgData.values);
        svgData.circle = g.selectAll("circle")
            .data(svgData.nodes)
            .enter().append("circle")
            .attr("class", function (d) { return d.parent ? d.children ? "node "+d.data.key : "node node--leaf" : "node node--root"; })
            .style("fill", function (d, i) { return !d.children ? color(parseInt(d.data["Points"])) : "#fafafa"; })
            .on("click", function (d) { if (svgData.focus !== d) zoom(d), d3.event.stopPropagation(); })

        var text = g.selectAll("text")
            .data(svgData.nodes)
            .enter().append("text")
            .attr("class", "label")
            .style("fill-opacity", function (d) { return d.parent === root ? 1 : 0; })
            .style("display", function (d) { return d.parent === root ? "inline" : "none"; })
            .text(function (d) { return d.data.key || d.data.Player; });

        svgData.node = g.selectAll("circle,text");

        svg
            .style("background", "white")
            .on("click", function () { zoom(root); });

        zoomTo([root.x, root.y, root.r * 2 + margin]);
    });

   function zoom(d) {
    var focus0 = svgData.focus; svgData.focus = d;

    var transition = d3.transition()
        .duration(d3.event.altKey ? 7500 : 750)
        .tween("zoom", function(d) {
          var i = d3.interpolateZoom(view, [svgData.focus.x, svgData.focus.y, svgData.focus.r * 2 + margin]);
          return function(t) { zoomTo(i(t)); };
        });

    transition.selectAll("text")
      .filter(function(d) { return d.parent === svgData.focus || this.style.display === "inline"; })
        .style("fill-opacity", function(d) { return d.parent === svgData.focus ? 1 : 0; })
        .on("start", function(d) { if (d.parent === svgData.focus) this.style.display = "inline"; })
        .on("end", function(d) { if (d.parent !== svgData.focus) this.style.display = "none"; });
  }

  function zoomTo(v) {
    var k = diameter / v[2]; view = v;
    svgData.node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
    svgData.circle.attr("r", function(d) { return d.r * k; });
  }

    function makeNest(data, structure) {
        var nest = d3.nest();
        
        structure.forEach(function(level, idx) {
            var classes = level.classes;
            var nbOfClass = classes.length;
            var attribute = level.attribute;

            var attributeData = data.map(function(d) { return parseFloat(d[attribute]); }).sort(function(a,b) { return a-b; });
            var classSize = 1/nbOfClass;
            var steps = [];
            for(i = 0; i < nbOfClass; i++) {
                steps.push(d3.quantile(attributeData, 1-i*classSize));
            }

            nest = nest.key(function (d) {
                var attributedClass = undefined;
                steps.forEach(function(step, idx) {
                    if(parseFloat(d[attribute]) <= step) {
                        attributedClass = classes[idx]+escapeString(attribute);
                    }
                });
                return attributedClass;
            });
        })

        return nest.entries(data);
    }
    
    function makeQuantileScale(values) {
        return d3.scaleQuantile()
            .domain(values)
            .range(["#5e4fa2", "#3288bd", "#66c2a5", "#abdda4", "#e6f598", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"])
    }

    function ghostLow(svgId, limit) { // 1892 is the limit to use to highlight 10 best points
        svgData.nodes
            .filter(function (d) { return d.value < limit && d.depth === 4; }) // Hide all the circles below the limit
            .forEach(function (d, index) {
            var commonPartOfId = escapeString(d.data.id).split('-')[0]; // Keep only the common part of their id between svgs
                d3.selectAll(".node--leaf[id^=" + commonPartOfId + "-]")
                    .filter(function (dd) { return d.parent.value === dd.parent.value }) // eviter de cacher d'autres joueurs du même nom
                    .classed("ghost", true);
            });
    }

    function unghostAll() {
        d3.selectAll(".ghost").classed("ghost", false);
    }

    function toggleLabels() {
        if (showLabel) {
            showLabel = false;
            d3.selectAll(".label").classed("hidden-labels", true);
        } else {
            showLabel = true;
            d3.selectAll(".label.hidden-labels").classed("hidden-labels", false);
        }
    }

    function escapeString(str) {
        return str.replace(/[^a-zA-Z]/g, '_')
    }
    </script>
</body>

</html>