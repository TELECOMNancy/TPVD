<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Partition - Icicle</title>
    <style>

.node {
  fill: #ddd;
  stroke: #fff;
}

.label {
  font: 10px sans-serif;
  text-anchor: middle;
}

text{
    fill: black;
    stroke: none;
}
.ghost {
    opacity: 0.01;
}


</style>
<script src="https://d3js.org/d3.v4.min.js"></script>

</head>

<body>
        <header><h1>NBA</h1>
    <div class="scale">
        <p>Les valeurs sont colorées selon leur quantile. La hauteur des rectangles correspond au nombre de points du joueur.</p>
        <button onclick="ghostLow('points', 1892)">Mettre en évidence les 10 meilleurs</button>
        <button onclick="unghostAll()">Réinitialiser</button>
        </header>

        <script>
            var svgs = {};
            var width = 800,
                height = 500;

            var color = d3.scaleOrdinal(d3.schemeCategory20);

            function makeIcicle(id, attribute) {
                var quantile;

                var svg = d3.select("body").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("id", id);

                var partition = d3.partition()
                    .size([height, width])
                    .round(true);

                var format = d3.format(",d");

                d3.tsv("nba-no-hierarchy.txt", function (error, root) {
                    if (error) throw error;

                    root = d3.stratify()
                        .id(function (d) { return d.Player; })
                        .parentId(function (d) { return d.Team; })
                        (root);

                    var vals = [];
                    root = d3.hierarchy(root)
                        .sum(function (d) { if (d.data.Points) vals.push(d.data.Points); return d.data.Points; })
                        .sort(function (a, b) { return b.value - a.value; });

                    quantile = makeQuantileScale(vals);

                    partition(root);
                    svgs[id] = {nodes: root.descendants(), values: vals};

                    var cell = svg
                        .selectAll(".node")
                        .data(root.descendants())
                        .enter().append("g")
                        .attr("class", function (d) { return "node " + escapeString(d.data.id) + " " + (d.children ? " node--internal" : " node--leaf"); })
                        .attr("transform", function (d) { return "translate(" + d.y0 + "," + d.x0 + ")"; });

                    cell.append("rect")
                        .attr("id", function (d) { return "rect-" + escapeString(d.data.id); })
                        .attr("width", function (d) { return d.y1 - d.y0; })
                        .attr("height", function (d) { return d.x1 - d.x0; })
                        .filter(function (d) {
                            return d.depth > 3;
                        })
                        .style("fill", function (d) {
                                return quantile(d.data.data[attribute]);
                        });

                    cell.append("clipPath")
                        .attr("id", function (d) { return "clip-" + escapeString(d.data.id); })
                        .append("use")
                        .attr("xlink:href", function (d) { return "#rect-" + escapeString(d.data.id) + ""; });

                    cell.append("text")
                        .attr("clip-path", function (d) { return "url(#clip-" + escapeString(d.data.id) + ")"; })
                        .attr("x", 4)
                        .selectAll("tspan")
                        .data(function (d) { return d.data.children ? d.data.id : ""; }) // Ne pas afficher le nom des joueurs (illisible)
                        .enter().append("tspan")
                        .attr("y", 13)
                        .text(function (d) { return d; });

                    cell.append("title")
                        .text(function (d) { return d.data.id + "\n" + format(d.value) + " poitns"; });
                });
            }

            /////////////////////////////////////////


            function makeQuantileScale(values) {
                return d3.scaleQuantile()
                    .domain(values)
                    .range(["#5e4fa2", "#3288bd", "#66c2a5", "#abdda4", "#e6f598", "#fee08b", "#fdae61", "#f46d43", "#d53e4f", "#9e0142"])
            }

            function ghostLow(svgId, limit) { // 1892 is the limit to use to highlight 10 best points
                svgs[svgId].nodes
                    .filter(function (d) { return d.value < limit && d.depth === 4; }) // Hide all the circles below the limit
                    .forEach(function (d, index) {
                        d3.selectAll(".node--leaf." + escapeString(d.data.id))
                            .filter(function (dd) { return d.parent.value === dd.parent.value }) // eviter de cacher d'autres joueurs du même nom
                            .classed("ghost", true);
                        console.log(d);
                    });
            }

            function unghostAll() {
                d3.selectAll(".ghost").classed("ghost", false);
            }

            function toggleLabels() {
                if (showLabel) {
                    showLabel = false;
                    d3.selectAll(".label").classed("hidden-labels", true);
                } else {
                    showLabel = true;
                    d3.selectAll(".label.hidden-labels").classed("hidden-labels", false);
                }
            }

            function escapeString(str) {
                return str.replace(/[^a-zA-Z]/g, '_')
            }

            makeIcicle("points", "Points");
            makeIcicle("steals", "Steals");
        </script>
</body>

</html>